<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>地理投影动画演示</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/3.0.2/topojson.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        canvas {
            border: 1px solid #ccc;
            display: block;
            margin: 20px auto;
            max-width: 100%;
        }
        .controls {
            text-align: center;
            margin: 20px;
        }
        select {
            padding: 5px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <select id="projectionSelect">
            <option value="geoEquirectangular">Equirectangular</option>
            <option value="geoEckert3">Eckert III</option>
            <option value="geoMercator">Mercator</option>
            <option value="geoOrthographic">Orthographic</option>
            <option value="geoStereographic">Stereographic</option>
        </select>
        <span style="font-size: smaller; color: #666;">选择投影方式</span>
    </div>
    
    <canvas id="mapCanvas"></canvas>

    <script>
        // 配置
        const width = 954;
        const height = 600;
        
        // 获取canvas和context
        const canvas = document.getElementById('mapCanvas');
        const context = canvas.getContext('2d');
        canvas.width = width;
        canvas.height = height;
        
        // 全局变量
        let world = null;
        let land = null;
        let previousProjection = d3.geoEquirectangular().raw;
        let currentProjection = d3.geoEquirectangular().raw;
        let animationId = null;
        
        // 几何对象
        const outline = {type: "Sphere"};
        const graticule = d3.geoGraticule10();
        
        // 缓动函数
        const ease = d3.easeCubicInOut;
        
        // 投影映射
        const projectionMap = {
            'geoEquirectangular': d3.geoEquirectangular().raw,
            'geoEckert3': d3.geoEckert3().raw,
            'geoMercator': d3.geoMercator().raw,
            'geoOrthographic': d3.geoOrthographic().raw,
            'geoStereographic': d3.geoStereographic().raw
        };
        
        // 工具函数
        function lerp1(x0, x1, t) {
            return (1 - t) * x0 + t * x1;
        }
        
        function lerp2([x0, y0], [x1, y1], t) {
            return [(1 - t) * x0 + t * x1, (1 - t) * y0 + t * y1];
        }
        
        function fit(raw) {
            const p = d3.geoProjection(raw).fitExtent([[0.5, 0.5], [width - 0.5, height - 0.5]], outline);
            return {scale: p.scale(), translate: p.translate()};
        }
        
        function interpolateProjection(raw0, raw1) {
            const {scale: scale0, translate: translate0} = fit(raw0);
            const {scale: scale1, translate: translate1} = fit(raw1);
            
            return t => d3.geoProjection((x, y) => {
                try {
                    const p0 = raw0(x, y);
                    const p1 = raw1(x, y);
                    if (p0 && p1) {
                        return lerp2(p0, p1, t);
                    }
                    return p0 || p1;
                } catch (e) {
                    return [0, 0];
                }
            })
            .scale(lerp1(scale0, scale1, t))
            .translate(lerp2(translate0, translate1, t))
            .precision(0.1);
        }
        
        // 渲染函数
        function render(projection) {
            const path = d3.geoPath(projection, context);
            context.clearRect(0, 0, width, height);
            context.save();
            
            // 绘制背景
            context.beginPath();
            path(outline);
            context.clip();
            context.fillStyle = "#fff";
            context.fillRect(0, 0, width, height);
            
            // 绘制经纬网格
            context.beginPath();
            path(graticule);
            context.strokeStyle = "#ccc";
            context.stroke();
            
            // 绘制陆地
            if (land) {
                context.beginPath();
                path(land);
                context.fillStyle = "#000";
                context.fill();
            }
            
            context.restore();
            
            // 绘制边界
            context.beginPath();
            path(outline);
            context.strokeStyle = "#000";
            context.stroke();
        }
        
        // 更新动画
        function update() {
            const r0 = previousProjection;
            const r1 = currentProjection;
            
            if (r0 === r1) return;
            
            const interpolate = interpolateProjection(r0, r1);
            const steps = 45;
            let step = 0;
            
            function animate() {
                step++;
                const t = Math.min(1, ease(step / steps));
                const proj = interpolate(t);
                
                // 添加旋转效果
                proj.rotate([performance.now() / 100 % 360, 0]);
                
                render(proj);
                
                if (step < steps) {
                    animationId = requestAnimationFrame(animate);
                } else {
                    previousProjection = r1;
                }
            }
            
            animate();
        }
        
        // 加载世界地图数据
        async function loadWorldData() {
            try {
                // 使用Natural Earth的简化世界地图数据
                const response = await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/land-110m.json');
                world = await response.json();
                land = topojson.feature(world, world.objects.land);
                
                // 初始渲染
                render(d3.geoEquirectangular().fitExtent([[0.5, 0.5], [width - 0.5, height - 0.5]], outline));
            } catch (error) {
                console.error('加载地图数据失败:', error);
                // 即使没有地图数据也可以显示投影网格
                render(d3.geoEquirectangular().fitExtent([[0.5, 0.5], [width - 0.5, height - 0.5]], outline));
            }
        }
        
        // 事件监听
        document.getElementById('projectionSelect').addEventListener('change', function(e) {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            const selectedProjection = projectionMap[e.target.value];
            if (selectedProjection) {
                currentProjection = selectedProjection;
                update();
            }
        });
        
        // 初始化
        loadWorldData();
        
        // 持续的旋转动画
        function continuousRotation() {
            const proj = d3.geoProjection(currentProjection);
            proj.fitExtent([[0.5, 0.5], [width - 0.5, height - 0.5]], outline);
            proj.rotate([performance.now() / 100 % 360, 0]);
            render(proj);
            requestAnimationFrame(continuousRotation);
        }
        
        // 启动连续旋转（可选）
        // continuousRotation();
    </script>
</body>
</html>